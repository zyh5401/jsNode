<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		/*
			面向对象：
				面向对象是一种对现实世界的理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物；
				核心：
					抽象
						抽离
						长得像
			把一些具有特征的形态归为一类就加叫抽象。
			（抽象对于js来讲，可以理解为封装函数）

			把功能类似或者相同的代码抽离出来，归为一类。把一些描述性的特征，挂在这个类的原型上的一种编程思想。就叫做面向对象。

			new 
				函数运算符；
				new过后，函数返回值就变成了对象，函数里的this全部指向这个对对象，默认return 这个对象
				new 函数之后就叫实例化，他的返回值，就是实例化对象
				如果在构造函数中return了一个简单类型的，那么返回值不变，
				如果在构造函数中return了一个复合烈性，name返回值就是return后的东西；

			原型（prototype）
				函数的一个属性，值为对象	
				添加类样式，    
				原型是专门处理性能问题的；
				对象身上没有原型但是有原型链，函数身上既有原型又有原型链。

			_proto_:原型链
				实例化对象的原型链=构造函数的原型；
				原型链就是实例化对象与构造函数之间的桥梁
				方法的优先级关系；
				对象找链-构造函数的原型-构造函数原型下的链-构造构造函数的原型；
				构造函数的原型永远都是给它的实例化对象使用的的
			js面向对象的三大特征
				封装
				继承
				多态（抽象）

			继承：自己有一套自己的特征还具备父类的特征；
				拷贝继承：
				1属性继承：调用父类并且改变this指向（用call改变）；；
				2方法继承：利用中间桥梁，把子类的原型链，链接父级。再把子类属性，或方法，付给子类；
				注意，这种方法需要手动修改子类的prototype.constructor = 子类的构造函数；

				包装对象：
					当简单类型去掉用某个固定的属性或者方法的时候，那么系统内部会偷偷的把这个简单类型去转成对象类型，去掉用这个属性或方法。调用完成之后，这个包装对象就会销毁；
				instanceof
					运算符，左值是不是右值构造出来的；
				hasOwnProperty：
					某个属性是不是这个对乡下的；
				toString
					把别的数据类型转成字符串类型；
					每个内置对象都有toString方法；
					只要你使用alert，namealert函数会掉用tostring方法；
					obj.toString->[object Object]
					[object, 由什么内置函数构造出来的]
					用途：
					1转进制；
					num.toString（要转的进制数） 
					parseInt('110',2)//转进制
					2判断内置对象的实例化对象的构造函数是谁
					console.log(Object.prototype.toString.call(arr) ==='[object,Array]')
					debugger(断点查询bug)

				deepclone
					深度克隆函数：
					循环的时候，只要发现某个值为对象类型，那么继续循环这个对象类型，把对象类型中的值再赋值给另一个对象。
					function deepclone(obj){
						var toSting = Object.prototype.toString;
						var o = obj.push?[]:{};
						for(var attr in obj){
						if(toSting.call(obj[attr]) === '[object Object]' || toSting.call(obj[attr]) === '[object Array]'){
							o[attr] = deepclone(obj[attr]);
							}else{
								o[attr] = obj[attr];
							}
						}
							return o;
						}
				组件：
					是对数据和方法的简单封装；为了方便复用  
					组件是有配置参数，能够做到有配置，走配置，没配置走默认；
                                                                                                                                                                                                              

				ES6
				class 类写法
				class+类名{
					constructor（属性，属性2）{
						this.属性 = 属性
					}
					方法（）{
					}
				}
				注意，如果使用calss方式写类，那么prototype是不能够被改写的；
				类的继承方式；
				class 子类名 extends 父类名{
					constructor（属性，属性，属性）{
					super（属性，属性）
					this.属性= 属性
					//添加自己的属性
					}
					自己的方法（）{

					}
				}
		*/
	</script>
</body>
</html>